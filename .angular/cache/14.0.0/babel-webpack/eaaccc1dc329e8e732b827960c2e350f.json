{"ast":null,"code":"import { InjectionToken, Injectable, Inject, Injector, NgModule } from '@angular/core';\nimport { APP_BASE_HREF, DOCUMENT } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nconst COOKIE_OPTIONS = new InjectionToken('COOKIE_OPTIONS');\nconst COOKIE_WRITER = new InjectionToken('COOKIE_WRITER'); // tslint:disable-next-line:no-any\n\nfunction isNil(obj) {\n  return obj === undefined || obj === null;\n} // tslint:disable-next-line:no-any\n\n\nfunction isPresent(obj) {\n  return !isNil(obj);\n} // tslint:disable-next-line:no-any\n\n\nfunction isString(obj) {\n  return typeof obj === 'string';\n} // noinspection JSUnusedGlobalSymbols\n// tslint:disable-next-line:no-any\n\n\nfunction isEmpty(value) {\n  if (isNil(value)) {\n    return true;\n  }\n\n  if (value === {}) {\n    return true;\n  }\n\n  if (Array.isArray(value) && value.length === 0) {\n    return true;\n  }\n\n  if (typeof value !== 'boolean' && !value) {\n    return true;\n  } // noinspection RedundantIfStatementJS\n\n\n  if (Object.keys(value).length === 0 && value.constructor === Object) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergeOptions(oldOptions, newOptions) {\n  if (!newOptions) {\n    return oldOptions;\n  }\n\n  return {\n    path: isPresent(newOptions.path) ? newOptions.path : oldOptions.path,\n    domain: isPresent(newOptions.domain) ? newOptions.domain : oldOptions.domain,\n    expires: isPresent(newOptions.expires) ? newOptions.expires : oldOptions.expires,\n    secure: isPresent(newOptions.secure) ? newOptions.secure : oldOptions.secure,\n    sameSite: isPresent(newOptions.sameSite) ? newOptions.sameSite : oldOptions.sameSite,\n    httpOnly: isPresent(newOptions.httpOnly) ? newOptions.httpOnly : oldOptions.httpOnly,\n    storeUnencoded: isPresent(newOptions.storeUnencoded) ? newOptions.storeUnencoded : oldOptions.storeUnencoded\n  };\n}\n\nfunction parseCookieString(currentCookieString) {\n  let lastCookies = {};\n  let lastCookieString = '';\n  let cookieArray;\n  let cookie;\n  let i;\n  let index;\n  let name;\n\n  if (currentCookieString !== lastCookieString) {\n    lastCookieString = currentCookieString;\n    cookieArray = lastCookieString.split('; ');\n    lastCookies = {};\n\n    for (i = 0; i < cookieArray.length; i++) {\n      cookie = cookieArray[i];\n      index = cookie.indexOf('=');\n\n      if (index > 0) {\n        // ignore nameless cookies\n        name = safeDecodeURIComponent(cookie.substring(0, index)); // the first value that is seen for a cookie is the most\n        // specific one.  values for the same cookie name that\n        // follow are for less specific paths.\n\n        if (isNil(lastCookies[name])) {\n          lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));\n        }\n      }\n    }\n  }\n\n  return lastCookies;\n}\n\nfunction buildCookieString(name, value, options) {\n  let expires = options === null || options === void 0 ? void 0 : options.expires;\n  let val;\n\n  if (isNil(value)) {\n    expires = 'Thu, 01 Jan 1970 00:00:00 GMT';\n    val = '';\n  } else {\n    val = value;\n  }\n\n  if (isString(expires)) {\n    expires = new Date(expires);\n  }\n\n  const cookieValue = (options === null || options === void 0 ? void 0 : options.storeUnencoded) ? value : encodeURIComponent(val);\n  let str = encodeURIComponent(name) + '=' + cookieValue;\n  str += (options === null || options === void 0 ? void 0 : options.path) ? ';path=' + options.path : '';\n  str += (options === null || options === void 0 ? void 0 : options.domain) ? ';domain=' + options.domain : '';\n  str += expires ? ';expires=' + expires.toUTCString() : '';\n  str += (options === null || options === void 0 ? void 0 : options.sameSite) ? '; SameSite=' + options.sameSite : '';\n  str += (options === null || options === void 0 ? void 0 : options.secure) ? ';secure' : '';\n  str += (options === null || options === void 0 ? void 0 : options.httpOnly) ? '; HttpOnly' : ''; // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:\n  // - 300 cookies\n  // - 20 cookies per unique domain\n  // - 4096 bytes per cookie\n\n  const cookieLength = str.length + 1;\n\n  if (cookieLength > 4096) {\n    console.log('Cookie \\'' + name + '\\' possibly not set or overflowed because it was too large (' + cookieLength + ' > 4096 bytes)!');\n  }\n\n  return str;\n}\n\nfunction safeDecodeURIComponent(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (e) {\n    return str;\n  }\n}\n\nlet CookieOptionsProvider = /*#__PURE__*/(() => {\n  class CookieOptionsProvider {\n    constructor(options = {}, injector) {\n      this.injector = injector;\n      this.defaultOptions = {\n        path: this.injector.get(APP_BASE_HREF, '/'),\n        domain: undefined,\n        expires: undefined,\n        secure: false,\n        httpOnly: false\n      };\n      this.options = mergeOptions(this.defaultOptions, options);\n    }\n\n  }\n\n  CookieOptionsProvider.ɵfac = function CookieOptionsProvider_Factory(t) {\n    return new (t || CookieOptionsProvider)(ɵngcc0.ɵɵinject(COOKIE_OPTIONS), ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  CookieOptionsProvider.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: CookieOptionsProvider,\n    factory: CookieOptionsProvider.ɵfac\n  });\n  return CookieOptionsProvider;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CookieService = /*#__PURE__*/(() => {\n  class CookieService {\n    constructor(document, optionsProvider, cookieWriterService) {\n      this.document = document;\n      this.optionsProvider = optionsProvider;\n      this.cookieWriterService = cookieWriterService;\n      this.options = this.optionsProvider.options;\n    }\n    /**\n     * @description\n     * Returns if the given cookie key exists or not.\n     *\n     * @param key Id to use for lookup.\n     * @returns true if key exists, otherwise false.\n     */\n\n\n    hasKey(key) {\n      const value = this.get(key);\n      return isPresent(value);\n    }\n    /**\n     * @description\n     * Returns the value of given cookie key.\n     *\n     * @param key Id to use for lookup.\n     * @returns Raw cookie value.\n     */\n\n\n    get(key) {\n      var _a;\n\n      return (_a = this.getAll()) === null || _a === void 0 ? void 0 : _a[key];\n    }\n    /**\n     * @description\n     * Returns the deserialized value of given cookie key.\n     *\n     * @param key Id to use for lookup.\n     * @returns Deserialized cookie value.\n     */\n\n\n    getObject(key) {\n      const value = this.get(key);\n\n      if (isNil(value)) {\n        return undefined;\n      } else if (value === '') {\n        return {};\n      }\n\n      return JSON.parse(value);\n    }\n    /**\n     * @description\n     * Returns a key value object with all the cookies.\n     *\n     * @returns All cookies\n     */\n\n\n    getAll() {\n      const cookieString = this.cookieWriterService.readAllAsString();\n      return parseCookieString(cookieString);\n    }\n    /**\n     * @description\n     * Sets a value for given cookie key.\n     *\n     * @param key Id for the `value`.\n     * @param value Raw value to be stored.\n     * @param options (Optional) Options object.\n     */\n\n\n    put(key, value, options) {\n      const opts = mergeOptions(this.options, options);\n      this.cookieWriterService.write(key, value, opts);\n    }\n    /**\n     * @description\n     * Serializes and sets a value for given cookie key.\n     *\n     * @param key Id for the `value`.\n     * @param value Value to be stored.\n     * @param options (Optional) Options object.\n     */\n\n\n    putObject(key, value, options) {\n      this.put(key, JSON.stringify(value), options);\n    }\n    /**\n     * @description\n     * Remove given cookie.\n     *\n     * @param key Id of the key-value pair to delete.\n     * @param options (Optional) Options object.\n     */\n\n\n    remove(key, options) {\n      this.put(key, undefined, options);\n    }\n    /**\n     * @description\n     * Remove all cookies.\n     */\n\n\n    removeAll(options) {\n      const cookies = this.getAll();\n      Object.keys(cookies).forEach(key => this.remove(key, options));\n    }\n\n  }\n\n  CookieService.ɵfac = function CookieService_Factory(t) {\n    return new (t || CookieService)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(CookieOptionsProvider), ɵngcc0.ɵɵinject(COOKIE_WRITER));\n  };\n\n  CookieService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: CookieService,\n    factory: CookieService.ɵfac\n  });\n  return CookieService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CookieWriterService = /*#__PURE__*/(() => {\n  class CookieWriterService {\n    constructor(document) {\n      this.document = document;\n    }\n\n    readAllAsString() {\n      return this.document.cookie || '';\n    }\n\n    write(name, value, options) {\n      this.document.cookie = buildCookieString(name, value, options);\n    }\n\n  }\n\n  CookieWriterService.ɵfac = function CookieWriterService_Factory(t) {\n    return new (t || CookieWriterService)(ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n\n  CookieWriterService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: CookieWriterService,\n    factory: CookieWriterService.ɵfac\n  });\n  return CookieWriterService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction cookieServiceFactory(document, cookieOptionsProvider, cookieWriterService) {\n  return new CookieService(document, cookieOptionsProvider, cookieWriterService);\n}\n\nlet CookieModule = /*#__PURE__*/(() => {\n  class CookieModule {\n    /**\n     * Use this method in your root module to provide the CookieService\n     */\n    static forRoot(options = {}) {\n      return {\n        ngModule: CookieModule,\n        providers: [{\n          provide: COOKIE_OPTIONS,\n          useValue: options\n        }, {\n          provide: COOKIE_WRITER,\n          useClass: CookieWriterService\n        }, {\n          provide: CookieService,\n          useFactory: cookieServiceFactory,\n          deps: [DOCUMENT, CookieOptionsProvider, COOKIE_WRITER]\n        }]\n      };\n    }\n    /**\n     * Use this method in your other (non root) modules to import the directive/pipe\n     */\n\n\n    static forChild(options = {}) {\n      return CookieModule.forRoot(options);\n    }\n\n  }\n\n  CookieModule.ɵfac = function CookieModule_Factory(t) {\n    return new (t || CookieModule)();\n  };\n\n  CookieModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: CookieModule\n  });\n  CookieModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [CookieOptionsProvider]\n  });\n  return CookieModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ngx-cookie\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { COOKIE_OPTIONS, COOKIE_WRITER, CookieModule, CookieOptionsProvider, CookieService, CookieWriterService, buildCookieString, cookieServiceFactory, isEmpty, isNil, isPresent, isString, mergeOptions, parseCookieString, safeDecodeURIComponent }; //# sourceMappingURL=ngx-cookie.js.map","map":null,"metadata":{},"sourceType":"module"}